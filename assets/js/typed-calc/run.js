function _classCallCheck(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } function peg$subclass(t, e) { function r() { this.constructor = t } r.prototype = e.prototype, t.prototype = new r } function peg$SyntaxError(t, e, r, n) { this.message = t, this.expected = e, this.found = r, this.location = n, this.name = "SyntaxError", "function" == typeof Error.captureStackTrace && Error.captureStackTrace(this, peg$SyntaxError) } function peg$parse(t, e) { function r(t, e) { return { type: "literal", text: t, ignoreCase: e } } function n(t, e, r) { return { type: "class", parts: t, inverted: e, ignoreCase: r } } function o() { return { type: "end" } } function i(e) { var r, n = je[e]; if (n) return n; for (r = e - 1; !je[r];)r--; for (n = je[r], n = { line: n.line, column: n.column }; e > r;)10 === t.charCodeAt(r) ? (n.line++ , n.column = 1) : n.column++ , r++; return je[e] = n, n } function a(t, e) { var r = i(t), n = i(e); return { start: { offset: t, line: r.line, column: r.column }, end: { offset: e, line: n.line, column: n.column } } } function u(t) { Le > Re || (Re > Le && (Le = Re, Me = []), Me.push(t)) } function c(t, e, r) { return new peg$SyntaxError(peg$SyntaxError.buildMessage(t, e), t, e, r) } function s() { var e, r, n, o, i, a, c, s; if (e = Re, r = A(), r !== q) { for (n = [], 40 === t.charCodeAt(Re) ? (o = j, Re++) : (o = q, 0 === Pe && u(L)); o !== q;)n.push(o), 40 === t.charCodeAt(Re) ? (o = j, Re++) : (o = q, 0 === Pe && u(L)); n !== q ? (o = A(), o !== q ? (i = l(), i !== q ? (a = A(), a !== q ? (41 === t.charCodeAt(Re) ? (c = M, Re++) : (c = q, 0 === Pe && u(P)), c === q && (c = null), c !== q ? (s = A(), s !== q ? (Ze = e, r = U(i), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q) } else Re = e, e = q; return e } function l() { var t, e, r, n; if (t = Re, e = p(), e !== q) { for (r = [], n = l(); n !== q;)r.push(n), n = l(); r !== q ? (Ze = t, e = O(e, r), t = e) : (Re = t, t = q) } else Re = t, t = q; return t } function p() { var t; return t = d(), t === q && (t = f()), t } function f() { var e, r, n, o, i, a, c, s, p, f, d, y, h, g; if (e = Re, r = A(), r !== q) { for (n = [], 40 === t.charCodeAt(Re) ? (o = j, Re++) : (o = q, 0 === Pe && u(L)); o !== q;)n.push(o), 40 === t.charCodeAt(Re) ? (o = j, Re++) : (o = q, 0 === Pe && u(L)); n !== q ? (o = A(), o !== q ? (955 === t.charCodeAt(Re) ? (i = D, Re++) : (i = q, 0 === Pe && u(G)), i !== q ? (a = A(), a !== q ? (c = m(), c !== q ? (58 === t.charCodeAt(Re) ? (s = H, Re++) : (s = q, 0 === Pe && u(J)), s !== q ? (p = b(), p !== q ? (8594 === t.charCodeAt(Re) ? (f = K, Re++) : (f = q, 0 === Pe && u(Q)), f !== q ? (d = l(), d !== q ? (y = A(), y !== q ? (41 === t.charCodeAt(Re) ? (h = M, Re++) : (h = q, 0 === Pe && u(P)), h === q && (h = null), h !== q ? (g = A(), g !== q ? (Ze = e, r = V(c, p, d), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q) } else Re = e, e = q; return e } function d() { var t; return t = v(), t === q && (t = h(), t === q && (t = y(), t === q && (t = C(), t === q && (t = x(), t === q && (t = T(), t === q && (t = m(), t === q && (t = S()))))))), t } function y() { var t, e, r; return t = Re, e = g(), e !== q ? (r = l(), r !== q ? (Ze = t, e = W(e, r), t = e) : (Re = t, t = q)) : (Re = t, t = q), t } function h() { var t, e, r; return t = Re, e = F(), e !== q ? (r = l(), r !== q ? (Ze = t, e = X(r), t = e) : (Re = t, t = q)) : (Re = t, t = q), t } function g() { var t; return t = _(), t === q && (t = w()), t } function v() { var t, e, r, n, o, i, a; return t = Re, e = E(), e !== q ? (r = l(), r !== q ? (n = I(), n !== q ? (o = l(), o !== q ? (i = k(), i !== q ? (a = l(), a !== q ? (Ze = t, e = Y(r, o, a), t = e) : (Re = t, t = q)) : (Re = t, t = q)) : (Re = t, t = q)) : (Re = t, t = q)) : (Re = t, t = q)) : (Re = t, t = q), t } function b() { var t; return t = $(), t === q && (t = B()), t } function A() { var e, r; for (e = [], te.test(t.charAt(Re)) ? (r = t.charAt(Re), Re++) : (r = q, 0 === Pe && u(ee)); r !== q;)e.push(r), te.test(t.charAt(Re)) ? (r = t.charAt(Re), Re++) : (r = q, 0 === Pe && u(ee)); return e } function m() { var e, r, n, o, i; if (e = Re, r = Re, Pe++ , n = N(), Pe-- , n === q ? r = void 0 : (Re = r, r = q), r !== q) if (n = A(), n !== q) { if (o = [], re.test(t.charAt(Re)) ? (i = t.charAt(Re), Re++) : (i = q, 0 === Pe && u(ne)), i !== q) for (; i !== q;)o.push(i), re.test(t.charAt(Re)) ? (i = t.charAt(Re), Re++) : (i = q, 0 === Pe && u(ne)); else o = q; o !== q ? (i = A(), i !== q ? (Ze = e, r = oe(o), e = r) : (Re = e, e = q)) : (Re = e, e = q) } else Re = e, e = q; else Re = e, e = q; return e } function S() { var e, r, n, o, i, a, c, s; return e = Re, r = A(), r !== q ? (40 === t.charCodeAt(Re) ? (n = j, Re++) : (n = q, 0 === Pe && u(L)), n !== q ? (o = A(), o !== q ? (i = d(), i !== q ? (a = A(), a !== q ? (41 === t.charCodeAt(Re) ? (c = M, Re++) : (c = q, 0 === Pe && u(P)), c !== q ? (s = A(), s !== q ? (Ze = e, r = ie(i), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function x() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === ae ? (n = ae, Re += 4) : (n = q, 0 === Pe && u(ue)), n !== q ? (o = A(), o !== q ? (Ze = e, r = ce(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function T() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 5) === se ? (n = se, Re += 5) : (n = q, 0 === Pe && u(le)), n !== q ? (o = A(), o !== q ? (Ze = e, r = pe(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function C() { var e, r, n, o; return e = Re, r = A(), r !== q ? (48 === t.charCodeAt(Re) ? (n = fe, Re++) : (n = q, 0 === Pe && u(de)), n !== q ? (o = A(), o !== q ? (Ze = e, r = ye(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function N() { var t; return t = E(), t === q && (t = I(), t === q && (t = k(), t === q && (t = w(), t === q && (t = _(), t === q && (t = $(), t === q && (t = B(), t === q && (t = F(), t === q && (t = T())))))))), t } function E() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 2) === he ? (n = he, Re += 2) : (n = q, 0 === Pe && u(ge)), n !== q ? (o = A(), o !== q ? (r = [r, n, o], e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function I() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === ve ? (n = ve, Re += 4) : (n = q, 0 === Pe && u(be)), n !== q ? (o = A(), o !== q ? (r = [r, n, o], e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function k() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === Ae ? (n = Ae, Re += 4) : (n = q, 0 === Pe && u(me)), n !== q ? (o = A(), o !== q ? (r = [r, n, o], e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function w() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === Se ? (n = Se, Re += 4) : (n = q, 0 === Pe && u(xe)), n !== q ? (o = A(), o !== q ? (Ze = e, r = Te(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function _() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === Ce ? (n = Ce, Re += 4) : (n = q, 0 === Pe && u(Ne)), n !== q ? (o = A(), o !== q ? (Ze = e, r = Ee(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function $() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 3) === Ie ? (n = Ie, Re += 3) : (n = q, 0 === Pe && u(ke)), n !== q ? (o = A(), o !== q ? (Ze = e, r = we(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function B() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 4) === _e ? (n = _e, Re += 4) : (n = q, 0 === Pe && u($e)), n !== q ? (o = A(), o !== q ? (Ze = e, r = Be(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } function F() { var e, r, n, o; return e = Re, r = A(), r !== q ? (t.substr(Re, 6) === Fe ? (n = Fe, Re += 6) : (n = q, 0 === Pe && u(ze)), n !== q ? (o = A(), o !== q ? (Ze = e, r = qe(), e = r) : (Re = e, e = q)) : (Re = e, e = q)) : (Re = e, e = q), e } e = void 0 !== e ? e : {}; var z, q = {}, R = { Program: s }, Z = s, j = "(", L = r("(", !1), M = ")", P = r(")", !1), U = function (t) { return t }, O = function (t, e) { return e && e.length ? (e = e.pop(), { type: "application", left: t, right: e }) : t }, D = "λ", G = r("λ", !1), H = ":", J = r(":", !1), K = "→", Q = r("→", !1), V = function (t, e, r) { return { type: "abstraction", arg: { type: e, id: t }, body: r } }, W = function (t, e) { return { type: "arithmetic", operator: t, expression: e } }, X = function (t) { return { type: "is_zero", expression: t } }, Y = function (t, e, r) { return { type: "conditional_expression", condition: t, then: e, el: r } }, te = /^[ \t\r\n]/, ee = n([" ", "	", "\r", "\n"], !1, !1), re = /^[a-z]/, ne = n([["a", "z"]], !1, !1), oe = function (t) { return { name: t.join(""), type: "identifier" } }, ie = function (t) { return t }, ae = "true", ue = r("true", !1), ce = function () { return { type: "literal", value: !0 } }, se = "false", le = r("false", !1), pe = function () { return { type: "literal", value: !1 } }, fe = "0", de = r("0", !1), ye = function () { return { type: "literal", value: 0 } }, he = "if", ge = r("if", !1), ve = "then", be = r("then", !1), Ae = "else", me = r("else", !1), Se = "pred", xe = r("pred", !1), Te = function () { return "pred" }, Ce = "succ", Ne = r("succ", !1), Ee = function () { return "succ" }, Ie = "Nat", ke = r("Nat", !1), we = function () { return "Nat" }, _e = "Bool", $e = r("Bool", !1), Be = function () { return "Bool" }, Fe = "iszero", ze = r("iszero", !1), qe = function () { return "iszero" }, Re = 0, Ze = 0, je = [{ line: 1, column: 1 }], Le = 0, Me = [], Pe = 0; if ("startRule" in e) { if (!(e.startRule in R)) throw Error("Can't start parsing from rule \"" + e.startRule + '".'); Z = R[e.startRule] } if (z = Z(), z !== q && Re === t.length) return z; throw z !== q && Re < t.length && u(o()), c(Me, Le < t.length ? t.charAt(Le) : null, Le < t.length ? a(Le, Le + 1) : a(Le, Le)) } var _createClass = function () { function t(t, e) { for (var r = 0; r < e.length; r++) { var n = e[r]; n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, n.key, n) } } return function (e, r, n) { return r && t(e.prototype, r), n && t(e, n), e } }(); peg$subclass(peg$SyntaxError, Error), peg$SyntaxError.buildMessage = function (t, e) { function r(t) { return t.charCodeAt(0).toString(16).toUpperCase() } function n(t) { return t.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (t) { return "\\x0" + r(t) }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (t) { return "\\x" + r(t) }) } function o(t) { return t.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function (t) { return "\\x0" + r(t) }).replace(/[\x10-\x1F\x7F-\x9F]/g, function (t) { return "\\x" + r(t) }) } function i(t) { return c[t.type](t) } function a(t) { var e, r, n = Array(t.length); for (e = 0; e < t.length; e++)n[e] = i(t[e]); if (n.sort(), n.length > 0) { for (e = 1, r = 1; e < n.length; e++)n[e - 1] !== n[e] && (n[r] = n[e], r++); n.length = r } switch (n.length) { case 1: return n[0]; case 2: return n[0] + " or " + n[1]; default: return n.slice(0, -1).join(", ") + ", or " + n[n.length - 1] } } function u(t) { return t ? '"' + n(t) + '"' : "end of input" } var c = { literal: function (t) { return '"' + n(t.text) + '"' }, "class": function (t) { var e, r = ""; for (e = 0; e < t.parts.length; e++)r += t.parts[e] instanceof Array ? o(t.parts[e][0]) + "-" + o(t.parts[e][1]) : o(t.parts[e]); return "[" + (t.inverted ? "^" : "") + r + "]" }, any: function () { return "any character" }, end: function () { return "end of input" }, other: function (t) { return t.description } }; return "Expected " + a(t) + " but " + u(e) + " found." }; var SymbolTableImpl = function () { function t() { _classCallCheck(this, t), this.table = [] } return _createClass(t, [{ key: "push", value: function (t) { this.table.push(t) } }, { key: "lookup", value: function (t) { for (var e = this.table.length - 1; e >= 0; e -= 1) { var r = this.table[e].get(t); if (void 0 !== r) return r } return void 0 } }]), t }(), Scope = function () { function t() { _classCallCheck(this, t), this.map = {} } return _createClass(t, [{ key: "add", value: function (t, e) { this.map[t] = e } }, { key: "get", value: function (t) { return this.map[t] } }]), t }(), ASTNodes = { Abstraction: "abstraction", Condition: "conditional_expression", Identifier: "identifier", Literal: "literal", Arithmetic: "arithmetic", IsZero: "is_zero", Application: "application" }, SymbolTable = new SymbolTableImpl, Types = { Natural: "Nat", Boolean: "Bool" }, typeEq = function t(e, r) { if (e instanceof Array && r instanceof Array) { if (e.length !== r.length) return !1; for (var n = 0; n < e.length; n += 1)if (!t(e[n], r[n])) return !1; return !0 } return "string" == typeof e && "string" == typeof r ? e === r : !1 }, Check = function e(t, r) { if (r = r || [], !t) return { diagnostics: r }; if (t.type === ASTNodes.Literal) return 0 === t.value ? { diagnostics: r, type: Types.Natural } : t.value === !1 || t.value === !0 ? { diagnostics: r, type: Types.Boolean } : (r.push("Unknown type literal"), { diagnostics: r }); if (t.type === ASTNodes.Identifier) return { diagnostics: r, type: SymbolTable.lookup(t.name) }; if (t.type === ASTNodes.Condition) { if (!t.then || !t.el || !t.condition) return r.push("No condition for a conditional expression"), { diagnostics: r }; var n = e(t.condition); r = r.concat(n.diagnostics); var o = n.type; if (!typeEq(o, Types.Boolean)) return r.push("Incorrect type of condition of condition"), { diagnostics: r }; var i = e(t.then); r = r.concat(i.diagnostics); var a = i.type, u = e(t.el); r = r.concat(u.diagnostics); var c = u.type; return typeEq(a, c) ? i : (r.push("Incorrect type of then/else branches"), { diagnostics: r }) } if (t.type === ASTNodes.Abstraction) { var s = new Scope; if (s.add(t.arg.id.name, t.arg.type), SymbolTable.push(s), !t.body) return r.push("No body of a function"), { diagnostics: r }; var l = e(t.body), p = l.type; return r = r.concat(l.diagnostics), p ? { diagnostics: r, type: [t.arg.type, p] } : (r.push("Incorrect type of the body"), { diagnostics: r }) } if (t.type === ASTNodes.IsZero) { var f = e(t.expression); r = r.concat(f.diagnostics); var d = f.type; return typeEq(d, Types.Natural) ? { diagnostics: r, type: Types.Boolean } : (r.push("Incorrect type of IsZero"), { diagnostics: r }) } if (t.type === ASTNodes.Arithmetic) { var y = e(t.expression); r = r.concat(y.diagnostics); var h = y.type; return typeEq(h, Types.Natural) ? { diagnostics: r, type: Types.Natural } : (r.push("Incorrect type of " + t.operation), { diagnostics: r }) } if (t.type === ASTNodes.Application) { var g = e(t.left), v = g.type || []; r = r.concat(g.diagnostics); var b = e(t.right), A = b.type || []; return r = r.concat(b.diagnostics), v.length ? t.right && v[0] !== A ? (r.push("Incorrect type of application"), { diagnostics: r }) : { diagnostics: r, type: v[1] } : { diagnostics: r } } return { diagnostics: r } }, SymbolTable2 = new SymbolTableImpl, Eval = function r(t) { if (!t) return null; if (t.type === ASTNodes.Literal) return t.value; if (t.type === ASTNodes.Identifier) return SymbolTable2.lookup(t.name); if (t.type === ASTNodes.Condition) return r(r(t.condition) ? t.then : t.el); if (t.type === ASTNodes.Abstraction) { var e = new Scope; return function (n) { return e.add(t.arg.id.name, n), SymbolTable2.push(e), r(t.body) } } if (t.type === ASTNodes.IsZero) return 0 === r(t.expression); if (t.type === ASTNodes.Arithmetic) { var n = t.operator, o = r(t.expression); switch (n) { case "succ": return o + 1; case "pred": return 0 > o - 1 ? o : o - 1 } } else if (t.type === ASTNodes.Application) { var i = r(t.left), a = r(t.right); return i(a) } return !0 };

(function () {
  document.getElementById('add-lambda-btn').onclick = function () {
    document.getElementById('code').value += 'λ';
  };
  document.getElementById('add-arrow-btn').onclick = function () {
    document.getElementById('code').value += '→';
  };
  document.getElementById('eval-btn').onclick = function () {
    var code = document.getElementById('code').value;
    var ast = null;
    var result = '';
    try {
      var ast = peg$parse(code);
      var diagnostics = Check(ast).diagnostics;

      if (diagnostics.length) {
        result = diagnostics.join('. ');
      } else {
        result = Eval(ast);
      }
    } catch (e) {
      result = 'Syntax error. Unable to parse the program.';
    }
    document.getElementById('result').innerText = result;
  };
})();
